{
    "url": "https://api.github.com/repos/spack/spack/issues/8499",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/8499/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/8499/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/8499/events",
    "html_url": "https://github.com/spack/spack/issues/8499",
    "id": 333108701,
    "node_id": "MDU6SXNzdWUzMzMxMDg3MDE=",
    "number": 8499,
    "title": "Help passing info from dependencies up into dependents (for \"Python rpaths\" work)",
    "user": {
        "login": "hartzell",
        "id": 312978,
        "node_id": "MDQ6VXNlcjMxMjk3OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/312978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hartzell",
        "html_url": "https://github.com/hartzell",
        "followers_url": "https://api.github.com/users/hartzell/followers",
        "following_url": "https://api.github.com/users/hartzell/following{/other_user}",
        "gists_url": "https://api.github.com/users/hartzell/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/hartzell/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/hartzell/subscriptions",
        "organizations_url": "https://api.github.com/users/hartzell/orgs",
        "repos_url": "https://api.github.com/users/hartzell/repos",
        "events_url": "https://api.github.com/users/hartzell/events{/privacy}",
        "received_events_url": "https://api.github.com/users/hartzell/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 446630669,
            "node_id": "MDU6TGFiZWw0NDY2MzA2Njk=",
            "url": "https://api.github.com/repos/spack/spack/labels/dependencies",
            "name": "dependencies",
            "color": "c2e0c6",
            "default": false,
            "description": null
        },
        {
            "id": 446619758,
            "node_id": "MDU6TGFiZWw0NDY2MTk3NTg=",
            "url": "https://api.github.com/repos/spack/spack/labels/python",
            "name": "python",
            "color": "c2e0c6",
            "default": false,
            "description": null
        },
        {
            "id": 73908758,
            "node_id": "MDU6TGFiZWw3MzkwODc1OA==",
            "url": "https://api.github.com/repos/spack/spack/labels/question",
            "name": "question",
            "color": "cc317c",
            "default": true,
            "description": null
        }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2018-06-18T01:11:31Z",
    "updated_at": "2018-06-18T03:13:30Z",
    "closed_at": "2018-06-18T03:07:59Z",
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "[Plz don't get hung up on method/variable/file/... names, I still just trying to understand the wiring]\r\n\r\nI'm working on #8436 and my Python and/or Spack architectural naivete has me stumped.  The forehead-shaped dent in my desk suggests it's time to ask for help.\r\n\r\nIn pursuit of #8436 I'd like to have dependencies like `py-configparser` to be able to communicate info (e.g. any dirs that need to be added to Python's search path) back up the dependency graph to e.g. `py-flake8` so that it can write out a `.spack-rpaths` file.\r\n\r\nI've been trying to do it via `setup_dependent_package()`, but I'm stuck.\r\n\r\nI *can*:\r\n\r\n- define a method in `PythonPackage` that gets called in instances of classes that inherit from it (e.g. `PyFlake8`) and build up a list of paths in an attribute; and\r\n- add code to the `PyFlake8` class to write it out to a file.\r\n\r\nE.g.:\r\n\r\n```diff\r\ndiff --git a/lib/spack/spack/build_systems/python.py b/lib/spack/spack/build_systems/python.py\r\nindex 090516279..f42f78ca5 100644\r\n--- a/lib/spack/spack/build_systems/python.py\r\n+++ b/lib/spack/spack/build_systems/python.py\r\n@@ -419,3 +419,12 @@ class PythonPackage(PackageBase):\r\n\r\n     # Check that self.prefix is there after installation\r\n     run_after('install')(PackageBase.sanity_check_prefix)\r\n+\r\n+    def setup_dependent_package(self, module, dependent_spec):\r\n+        \"\"\"Add our prefix to the list of dirs that need to be added\r\n+           to the python rpaths [SIC] file.\r\n+        \"\"\"\r\n+\r\n+        paths = getattr(module, 'python_rpaths', [])\r\n+        paths.append(self.prefix)\r\n+        setattr(module, 'python_rpaths', paths)\r\ndiff --git a/var/spack/repos/builtin/packages/py-flake8/package.py b/var/spack/repos/builtin/packages/py-flake8/package.py\r\nindex 81a583895..fdefc3851 100644\r\n--- a/var/spack/repos/builtin/packages/py-flake8/package.py\r\n+++ b/var/spack/repos/builtin/packages/py-flake8/package.py\r\n@@ -76,3 +76,11 @@ class PyFlake8(PythonPackage):\r\n     def patch(self):\r\n         \"\"\"Filter pytest-runner requirement out of setup.py.\"\"\"\r\n         filter_file(\"['pytest-runner']\", \"[]\", 'setup.py', string=True)\r\n+\r\n+    @run_after('install')\r\n+    def write_rpath_file(self):\r\n+        spec = self.spec\r\n+        mkdirp(spec.prefix.bin)\r\n+\r\n+        with open(spec.prefix.bin.join(\".spack-rpaths-via-setup\"), 'w') as the_file:\r\n+            the_file.write(\"\\n\".join(python_rpaths) + \"\\n\")\r\n```\r\n\r\nBut if I move the definition of `write_rpath_file` up into `PythonPackage` or `PackageBase` it fails with something like:\r\n\r\n```\r\n==> Error: AttributeError: 'module' object has no attribute 'python_rpaths'\r\n```\r\n\r\nI more-or-less understand that I'm cramming that attribute directly into the dependent module's world, and can imagine why it wouldn't resolve for a method created up in the parent *module*, but the whole thing seems less than useful (yeah, I know, it's not *all* about me...).\r\n\r\nAs an alternative, I tried defining a property (a `[]`) up in `PackageBase` and using `module` in `setup_dependent_package` to access it, but I couldn't make up any syntax that Python thought was reasonable.\r\n\r\nIs there a way to use `setup_dependent_package` to do what I'm trying to do or is it the wrong tool for the job?\r\n\r\nI also explored another alternative that might be more appropriate.  The design discussed above pushes info up from the dependencies.  I also thought about having the dependencies add it as some sort of \"metadata\" and then pulling it out by looping over the top-level `spec.dependencies()` but I wasn't sure whether that's an approved use of the spec (let alone getting the syntax to work out).",
    "performed_via_github_app": null
}