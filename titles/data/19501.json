{
    "url": "https://api.github.com/repos/spack/spack/issues/19501",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/19501/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/19501/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/19501/events",
    "html_url": "https://github.com/spack/spack/pull/19501",
    "id": 728501570,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTA5MTk4OTEz",
    "number": 19501,
    "title": "Experimental ASP-based concretizer",
    "user": {
        "login": "alalazo",
        "id": 4199709,
        "node_id": "MDQ6VXNlcjQxOTk3MDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4199709?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alalazo",
        "html_url": "https://github.com/alalazo",
        "followers_url": "https://api.github.com/users/alalazo/followers",
        "following_url": "https://api.github.com/users/alalazo/following{/other_user}",
        "gists_url": "https://api.github.com/users/alalazo/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/alalazo/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/alalazo/subscriptions",
        "organizations_url": "https://api.github.com/users/alalazo/orgs",
        "repos_url": "https://api.github.com/users/alalazo/repos",
        "events_url": "https://api.github.com/users/alalazo/events{/privacy}",
        "received_events_url": "https://api.github.com/users/alalazo/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 446623646,
            "node_id": "MDU6TGFiZWw0NDY2MjM2NDY=",
            "url": "https://api.github.com/repos/spack/spack/labels/concretization",
            "name": "concretization",
            "color": "006b75",
            "default": false,
            "description": null
        }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 81,
    "created_at": "2020-10-23T20:21:15Z",
    "updated_at": "2021-01-18T14:57:29Z",
    "closed_at": "2020-11-17T18:04:17Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "pull_request": {
        "url": "https://api.github.com/repos/spack/spack/pulls/19501",
        "html_url": "https://github.com/spack/spack/pull/19501",
        "diff_url": "https://github.com/spack/spack/pull/19501.diff",
        "patch_url": "https://github.com/spack/spack/pull/19501.patch"
    },
    "body": "This adds an experimental concretizer to Spack that makes use of [Answer Set Programming](https://en.wikipedia.org/wiki/Answer_set_programming).  The new solver uses `clingo`, the combined grounder (`gringo`) and solver (`clasp`) from [Potassco](https://potassco.org/), instead of attempting to do the entire solve in Python as we did before.\r\n\r\n## Problem\r\n\r\nThe current concretizer is not exhaustive and is not guaranteed to find a solution if one exists.  It is greedy, does not do backtracking, and as a result the errors it gives can be confusing.  In many cases it can resolve a constraint too early -- it assigns final values to nodes as it builds the graph, and it may assign a version, variant, or other value to a node without considering the entire problem.  This can result in the concretizer finding conflicts where solutions exist.\r\n\r\nExtending the current concretizer is difficult.  There are many moving pieces, and rewriting any of them can be a lot of work.  Making major changes to concretization semantics is difficult, and increasingly we're unable to add features that users need.\r\n\r\nThe concretization problem that Spack solves is NP-complete (as is regular old dependency resolution with just versions), so we have decided to start using more powerful solvers to address it.  Using Clingo is a step in this direction.\r\n\r\n## How it works\r\n\r\nAnswer Set programming looks like [Prolog](https://en.wikipedia.org/wiki/Prolog) but has the advantage that, rather than trying to be a full programming language, it reduces logic problems to [CDCL SAT](https://en.wikipedia.org/wiki/Conflict-driven_clause_learning) with optimization.  ASP has the nice property that solves will always terminate (unlike Prolog programs), and it follows the [stable model semantics](https://en.wikipedia.org/wiki/Stable_model_semantics), which makes it easier to model some of the default-driven behavior in Spack.  The constraints in Spack are essentially SAT clauses, and our preferences (like [`packages.yaml`](https://spack.readthedocs.io/en/latest/build_settings.html)) add optimization weights to this.  We don't just want *a* solution -- we want the best one, with preferred variants, compilers, etc.\r\n\r\nThe prior concretizer iteratively expanded nodes in the graph and attempted to unify them greedily as they were expanded.  It used a fixed-point algorithm; iterating and expanding optional dependencies, replacing virtuals with providers, setting variants, versions, and compilers, etc. until there were no more changes to the DAG.\r\n\r\nThe new concretizer is less dynamic.  It works like this:\r\n\r\n1. Look at the input specs and read in *all possible dependencies*\r\n2. Translate constraints in Spack's package DSL to rules and facts in ASP.  e.g., `zlib` has some facts like this:\r\n    ```prolog\r\n    version_declared(\"zlib\",\"1.2.11\",0).\r\n    version_declared(\"zlib\",\"1.2.8\",1).\r\n    version_declared(\"zlib\",\"1.2.3\",2).\r\n\r\n    variant(\"zlib\",\"optimize\").\r\n    variant_single_value(\"zlib\",\"optimize\").\r\n    variant_default_value_from_package_py(\"zlib\",\"optimize\",\"True\").\r\n    variant_possible_value(\"zlib\",\"optimize\",\"False\").\r\n    variant_possible_value(\"zlib\",\"optimize\",\"True\").\r\n    ```\r\n    These come directly from `version()` and `variant()` directives in the `zlib/package.py` file.\r\n3. Combine these facts with the logic program in `lib/spack/spack/solver/concretize.lp`.  This defines all the rules and optimization criteria used in concretization in Spack.\r\n4. Send the whole program off to Clingo\r\n5. Read back one the optimal stable model found by the solver, and build a concrete `Spec` from it.\r\n\r\nOne nice thing about this is that it's declarative; we can add extra constraints and features more easily now, without having to reengineer the entire algorithm.  Another is that we can solve much more complex problems than we could before.  Finally, it will be easier going forward to implement many of the features we have planned (compilers as dependencies, optimizing for installed packages, etc.) using a real solver.\r\n\r\n## Error reporting\r\n\r\nWe are using Clingo's support for finding [unsatisfiable cores](https://en.wikipedia.org/wiki/Unsatisfiable_core) to generate error messages.  If something fails to concretize, the solver will tell you why by reporting a set of facts and rules that cannot be resolved together.  This can be very useful, as often it points directly to conflicts and can be used, with a little staring, to debug issues.  In other cases the core can still be quite large, and thus hard to interpret.  Cores are not guaranteed to be minimal by Clingo.  Improving these messages and converting them to understandable sentences is on our list of follow-on activities.\r\n\r\n## Alternatives\r\n\r\nThere are more details on alternatives in [this FOSDEM talk](https://archive.fosdem.org/2020/schedule/event/dependency_solving_not_just_sat/).  So far, Clingo works well, but we are also investigating [Z3](https://github.com/Z3Prover/z3), an SMT solver.  Z3 is more widely used and has a richer API, but its input language is in some sense more primitive, in that it doesn't accept or automatically ground first-order logic like Clingo.  We are investigating which solver will be easiest to include (vendor) with Spack so that we can use the new concretizer everywhere.\r\n\r\n## Using the new concretizer\r\n\r\nThere is a new section in `config.yaml`:\r\n\r\n```yaml\r\n  # The concretization algorithm to use in Spack. Options are:\r\n  #\r\n  #   'original': Spack's original greedy, fixed-point concretizer. This\r\n  #       algorithm can make decisions too early and will not backtrack\r\n  #       sufficiently for many specs.\r\n  #\r\n  #   'clingo': Uses a logic solver under the hood to solve DAGs with full\r\n  #       backtracking and optimization for user preferences.\r\n  #\r\n  # 'clingo' currently requires the clingo ASP solver to be installed and\r\n  # built with python bindings. 'original' is built in.\r\n  concretizer: original\r\n```\r\n\r\n1. You'll need to set `concretizer:` to `clingo` to use `clingo` everywhere.\r\n2. You will also need to `spack install clingo@master` and get `clingo` on your `PATH` to use the new concretizer.\r\n\r\nEven if the new concretizer is *not* enabled, you can use the `spack solve` command as you would normally use `spack spec` -- it will try to use the new concretizer.  `spack solve` will eventually go away but for now we have two commands.\r\n\r\n# Bugs fixed\r\n\r\nfixes #267\r\nfixes #303\r\nfixes #1781\r\nfixes #2310\r\nfixes #2632\r\nfixes #3628\r\nfixes #4635\r\nfixes #5651\r\nfixes #7339\r\nfixes #8082\r\nfixes #9025\r\nfixes #9414 \r\nfixes #9696\r\nfixes #9744\r\nfixes #9753\r\nfixes #9911\r\nfixes #12431\r\nfixes #19764",
    "performed_via_github_app": null
}