{
    "url": "https://api.github.com/repos/spack/spack/issues/13973",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/13973/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/13973/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/13973/events",
    "html_url": "https://github.com/spack/spack/issues/13973",
    "id": 532361672,
    "node_id": "MDU6SXNzdWU1MzIzNjE2NzI=",
    "number": 13973,
    "title": "Add new package directive to support packages with 100's of resources",
    "user": {
        "login": "hartzell",
        "id": 312978,
        "node_id": "MDQ6VXNlcjMxMjk3OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/312978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hartzell",
        "html_url": "https://github.com/hartzell",
        "followers_url": "https://api.github.com/users/hartzell/followers",
        "following_url": "https://api.github.com/users/hartzell/following{/other_user}",
        "gists_url": "https://api.github.com/users/hartzell/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/hartzell/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/hartzell/subscriptions",
        "organizations_url": "https://api.github.com/users/hartzell/orgs",
        "repos_url": "https://api.github.com/users/hartzell/repos",
        "events_url": "https://api.github.com/users/hartzell/events{/privacy}",
        "received_events_url": "https://api.github.com/users/hartzell/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 501899682,
            "node_id": "MDU6TGFiZWw1MDE4OTk2ODI=",
            "url": "https://api.github.com/repos/spack/spack/labels/RFC",
            "name": "RFC",
            "color": "d93f0b",
            "default": false,
            "description": null
        },
        {
            "id": 73908756,
            "node_id": "MDU6TGFiZWw3MzkwODc1Ng==",
            "url": "https://api.github.com/repos/spack/spack/labels/feature",
            "name": "feature",
            "color": "84b6eb",
            "default": false,
            "description": null
        },
        {
            "id": 475567363,
            "node_id": "MDU6TGFiZWw0NzU1NjczNjM=",
            "url": "https://api.github.com/repos/spack/spack/labels/resources",
            "name": "resources",
            "color": "c5def5",
            "default": false,
            "description": null
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-12-04T00:34:05Z",
    "updated_at": "2019-12-04T22:54:55Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "edits:\r\n - Touched up the demo code, `resources.json` is now an array of resource \"objects\", rather than a bunch of lines of individual resource objects.\r\n - Suggested alternative names for new directive.\r\n\r\n---\r\n\r\n**TL;DR**:  Looking for feedback on whether it's worth investing more work on a new package directive that would avoid having 1000's of lines in the package definitions for Go applications.\r\n\r\n---\r\n\r\nI'm improving our support for Go packages (#13023) and it looks like Go packages could easily need to define 100's of resources.  Describing them with  with `resource()` statements is gross.\r\n\r\nI'd like to add (see below for a prototype) an additional directive for the package language: `import_resources`.  It would be used like so:\r\n\r\n```python\r\nimport_resources(\"resources-2.0.4.json\", when=\"@2.0.4\")\r\n```\r\n\r\nand would have the same effect as explicitly including `resource()` statements for all of the resources described in `resources-2.0.4.json`.\r\n\r\nThe JSON description might look something like this:\r\n\r\n```js\r\n[\r\n  {\r\n    \"name\": \"github.com/Azure/go-ansiterm\",\r\n    \"git\": \"https://github.com/Azure/go-ansiterm\",\r\n    \"commit\": \"d6e3b3328b78\",\r\n    \"placement\": \"vendor/github.com/Azure/go-ansiterm\",\r\n    \"when\": \"@2.0.4\",\r\n    \"destination\": \".\"\r\n  },\r\n  {\r\n    \"name\": \"github.com/Microsoft/go-winio\",\r\n    \"git\": \"https://github.com/Microsoft/go-winio\",\r\n    \"tag\": \"v0.4.11\",\r\n    \"placement\": \"vendor/github.com/Microsoft/go-winio\",\r\n    \"when\": \"@2.0.4\",\r\n    \"destination\": \".\"\r\n  }\r\n]\r\n```\r\n\r\nThere [is/will be tooling](https://github.com/dmgk/modules2tuple/pull/8) that Go application packagers can use to generate the required statements mechanically from information in the application's source tree.  It currently generates `resource()` statements that can be pasted into the `package.py`.\r\n\r\nI'm not wed to the directive name.  Perhaps just `resources`, `load_resources`, `bulk_resources`, or `resources_from_json`?\r\n\r\nI'm not wed to using JSON for the imported file but whatever format we settle on should be easily machine writable and readable.\r\n\r\nThe implementation (so far) involves breaking out the body of the existing `_execute_resource()` into a function that can be shared by `resource()` and  `import_resources()`, adjusting `resource()` to use the new function, and adding an implementation for `_execute_import_resources()` that reads the JSON input file and uses the new function to add each of the resources.\r\n\r\nA quick-and-dirty one-shot see-if-it-works implementation (@tgamblin -- this might explain the mysterious headache you just developed...) might look like so:\r\n\r\n```diff\r\ndiff --git a/lib/spack/spack/directives.py b/lib/spack/spack/directives.py\r\nindex d877d4a19..2cd18aaa4 100644\r\n--- a/lib/spack/spack/directives.py\r\n+++ b/lib/spack/spack/directives.py\r\n@@ -30,6 +30,7 @@ class OpenMpi(Package):\r\n\r\n import collections\r\n import functools\r\n+import json\r\n import os.path\r\n import re\r\n from six import string_types\r\n@@ -607,38 +608,60 @@ def resource(**kwargs):\r\n       resource is moved into the main package stage area.\r\n     \"\"\"\r\n     def _execute_resource(pkg):\r\n-        when = kwargs.get('when')\r\n+        _resource(pkg, **kwargs)\r\n+    return _execute_resource\r\n+\r\n+def _resource(pkg, **kwargs):\r\n+    print(kwargs)\r\n+    when = kwargs.get('when')\r\n+    when_spec = make_when_spec(when)\r\n+    if not when_spec:\r\n+        return\r\n+\r\n+    destination = kwargs.get('destination', \"\")\r\n+    placement = kwargs.get('placement', None)\r\n+\r\n+    # Check if the path is relative\r\n+    if os.path.isabs(destination):\r\n+        message = ('The destination keyword of a resource directive '\r\n+                   'can\\'t be an absolute path.\\n')\r\n+        message += \"\\tdestination : '{dest}\\n'\".format(dest=destination)\r\n+        raise RuntimeError(message)\r\n+\r\n+    # Check if the path falls within the main package stage area\r\n+    test_path = 'stage_folder_root'\r\n+    normalized_destination = os.path.normpath(\r\n+    os.path.join(test_path, destination)\r\n+    )  # Normalized absolute path\r\n+\r\n+    if test_path not in normalized_destination:\r\n+        message = (\"The destination folder of a resource must fall \"\r\n+                   \"within the main package stage directory.\\n\")\r\n+        message += \"\\tdestination : '{dest}'\\n\".format(dest=destination)\r\n+        raise RuntimeError(message)\r\n+\r\n+    resources = pkg.resources.setdefault(when_spec, [])\r\n+    name = kwargs.get('name')\r\n+    fetcher = from_kwargs(**kwargs)\r\n+    resources.append(Resource(name, fetcher, destination, placement))\r\n+\r\n+@directive('imported_resources')\r\n+def import_resources(filename, when=None):\r\n+    def _execute_import_resources(pkg):\r\n         when_spec = make_when_spec(when)\r\n         if not when_spec:\r\n             return\r\n\r\n-        destination = kwargs.get('destination', \"\")\r\n-        placement = kwargs.get('placement', None)\r\n-\r\n-        # Check if the path is relative\r\n-        if os.path.isabs(destination):\r\n-            message = ('The destination keyword of a resource directive '\r\n-                       'can\\'t be an absolute path.\\n')\r\n-            message += \"\\tdestination : '{dest}\\n'\".format(dest=destination)\r\n-            raise RuntimeError(message)\r\n-\r\n-        # Check if the path falls within the main package stage area\r\n-        test_path = 'stage_folder_root'\r\n-        normalized_destination = os.path.normpath(\r\n-            os.path.join(test_path, destination)\r\n-        )  # Normalized absolute path\r\n-\r\n-        if test_path not in normalized_destination:\r\n-            message = (\"The destination folder of a resource must fall \"\r\n-                       \"within the main package stage directory.\\n\")\r\n-            message += \"\\tdestination : '{dest}'\\n\".format(dest=destination)\r\n-            raise RuntimeError(message)\r\n-\r\n-        resources = pkg.resources.setdefault(when_spec, [])\r\n-        name = kwargs.get('name')\r\n-        fetcher = from_kwargs(**kwargs)\r\n-        resources.append(Resource(name, fetcher, destination, placement))\r\n-    return _execute_resource\r\n+        # See patch.py::FilePatch\r\n+        pkg_dir = os.path.abspath(os.path.dirname(pkg.module.__file__))\r\n+        path = os.path.join(pkg_dir, filename)\r\n+\r\n+        with open(path) as fh:\r\n+            resources = json.load(fh)\r\n+            for r in resources:\r\n+                _resource(pkg, **r)\r\n+\r\n+    return _execute_import_resources\r\n\r\n\r\n class DirectiveError(spack.error.SpackError):\r\n```\r\n\r\nThis hack is able to import the 23 resources that are needed to build `docui`, replacing [the 120+ lines that are required](https://github.com/hartzell/spack/blob/feature/go-package-support/var/spack/repos/builtin/packages/docui/package.py#L20-L145) to define them using `resource()`, as well as all of the resources required for its dependencies (e.g. `go`).\r\n\r\n**Thoughts?**",
    "performed_via_github_app": null
}