{
    "url": "https://api.github.com/repos/spack/spack/issues/18186",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/18186/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/18186/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/18186/events",
    "html_url": "https://github.com/spack/spack/issues/18186",
    "id": 682300800,
    "node_id": "MDU6SXNzdWU2ODIzMDA4MDA=",
    "number": 18186,
    "title": "spack test lib/spack/spack/test/cmd/install.py::test_compiler_bootstrap on aarch64",
    "user": {
        "login": "fun2yang",
        "id": 45593608,
        "node_id": "MDQ6VXNlcjQ1NTkzNjA4",
        "avatar_url": "https://avatars.githubusercontent.com/u/45593608?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fun2yang",
        "html_url": "https://github.com/fun2yang",
        "followers_url": "https://api.github.com/users/fun2yang/followers",
        "following_url": "https://api.github.com/users/fun2yang/following{/other_user}",
        "gists_url": "https://api.github.com/users/fun2yang/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/fun2yang/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/fun2yang/subscriptions",
        "organizations_url": "https://api.github.com/users/fun2yang/orgs",
        "repos_url": "https://api.github.com/users/fun2yang/repos",
        "events_url": "https://api.github.com/users/fun2yang/events{/privacy}",
        "received_events_url": "https://api.github.com/users/fun2yang/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 73908754,
            "node_id": "MDU6TGFiZWw3MzkwODc1NA==",
            "url": "https://api.github.com/repos/spack/spack/labels/bug",
            "name": "bug",
            "color": "fc2929",
            "default": true,
            "description": null
        },
        {
            "id": 1433532775,
            "node_id": "MDU6TGFiZWwxNDMzNTMyNzc1",
            "url": "https://api.github.com/repos/spack/spack/labels/triage",
            "name": "triage",
            "color": "ed9793",
            "default": false,
            "description": "The issue needs to be prioritized"
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 2,
    "created_at": "2020-08-20T02:15:18Z",
    "updated_at": "2020-08-23T16:19:49Z",
    "closed_at": null,
    "author_association": "NONE",
    "active_lock_reason": null,
    "body": "### Steps to reproduce the issue\r\n\r\n```console\r\n$ spack test lib/spack/spack/test/cmd/install.py::test_compiler_bootstrap\r\n```\r\n\r\n### Error Message\r\n<pre>\r\n$ spack test -s -v lib/spack/spack/test/cmd/install.py::test_compiler_bootstrap\r\n============================================================================================ test session starts =============================================================================================\r\nplatform linux -- Python 3.6.8, pytest-3.2.5, py-1.4.34, pluggy-0.4.0 -- /usr/bin/python3\r\ncachedir: .cache\r\nrootdir: /home/yang/spack, inifile: pytest.ini\r\ncollected 1 item\r\n\r\nlib/spack/spack/test/cmd/install.py::test_compiler_bootstrap[mock_archive0] FAILED\r\n========================================================================================== short test summary info ===========================================================================================\r\nFAIL lib/spack/spack/test/cmd/install.py::test_compiler_bootstrap[mock_archive0]\r\n\r\n========================================================================================= slowest 20 test durations ==========================================================================================\r\n1.70s call     lib/spack/spack/test/cmd/install.py::test_compiler_bootstrap[mock_archive0]\r\n0.04s setup    lib/spack/spack/test/cmd/install.py::test_compiler_bootstrap[mock_archive0]\r\n0.00s teardown lib/spack/spack/test/cmd/install.py::test_compiler_bootstrap[mock_archive0]\r\n================================================================================================== FAILURES ==================================================================================================\r\n___________________________________________________________________________________ test_compiler_bootstrap[mock_archive0] ___________________________________________________________________________________\r\n\r\ninstall_mockery_mutable_config = None, mock_packages = <spack.repo.RepoPath object at 0xffffb3e024e0>, mock_fetch = None\r\nmock_archive = Archive(url='file:///tmp/pytest-of-yang/pytest-39/mock-archive-dir0/spack-src.tar.gz', path='/tmp/pytest-of-yang/pytes... archive_file='/tmp/pytest-of-yang/pytest-39/mock-archive-dir0/spack-src.tar.gz', expanded_archive_basedir='spack-src')\r\nmutable_config = <spack.config.Configuration object at 0xffffb3dfd048>, monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0xffffb3e0f048>\r\n\r\n    def test_compiler_bootstrap(\r\n            install_mockery_mutable_config, mock_packages, mock_fetch,\r\n            mock_archive, mutable_config, monkeypatch):\r\n        monkeypatch.setattr(spack.concretize.Concretizer,\r\n                            'check_for_compiler_existence', False)\r\n        spack.config.set('config:install_missing_compilers', True)\r\n        assert CompilerSpec('gcc@2.0') not in compilers.all_compiler_specs()\r\n\r\n        # Test succeeds if it does not raise an error\r\n>       install('a%gcc@2.0')\r\n\r\nlib/spack/spack/test/cmd/install.py:733:\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nlib/spack/spack/main.py:545: in __call__\r\n    self.command, self.parser, args, unknown)\r\nlib/spack/spack/main.py:489: in _invoke_command\r\n    return_val = command(parser, args)\r\nlib/spack/spack/cmd/install.py:386: in install\r\n    install_spec(args, kwargs, abstract, concrete)\r\nlib/spack/spack/cmd/install.py:243: in install_spec\r\n    spec.package.do_install(**kwargs)\r\nlib/spack/spack/package.py:1475: in do_install\r\n    builder.install(**kwargs)\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\n\r\nself = PackageInstaller(pkg=<spack.pkg.builtin.mock.a.A object at 0xffffb3d56e48>, pkg_id='a', build_pq=[], build_tasks={}, f...=1, debug=False, desc=' (b)', default_timeout=1e-09, pid=None, old_pid=None, host=None, old_host=None, _enable=True))})\r\nkwargs = {'cache_only': False, 'dirty': True, 'explicit': True, 'fail_fast': False, ...}, fail_fast = False, install_deps = True, keep_prefix = True, keep_stage = False, restage = True\r\nfail_fast_err = 'Terminating after first install failure', install_package = True\r\n\r\n    def install(self, **kwargs):\r\n        \"\"\"\r\n            Install the package and/or associated dependencies.\r\n\r\n            Args:\"\"\"\r\n\r\n        fail_fast = kwargs.get('fail_fast', False)\r\n        install_deps = kwargs.get('install_deps', True)\r\n        keep_prefix = kwargs.get('keep_prefix', False)\r\n        keep_stage = kwargs.get('keep_stage', False)\r\n        restage = kwargs.get('restage', False)\r\n\r\n        fail_fast_err = 'Terminating after first install failure'\r\n\r\n        # install_package defaults True and is popped so that dependencies are\r\n        # always installed regardless of whether the root was installed\r\n        install_package = kwargs.pop('install_package', True)\r\n\r\n        # Ensure not attempting to perform an installation when user didn't\r\n        # want to go that far.\r\n        self._check_last_phase(**kwargs)\r\n\r\n        # Skip out early if the spec is not being installed locally (i.e., if\r\n        # external or upstream).\r\n        not_local = _handle_external_and_upstream(self.pkg, True)\r\n        if not_local:\r\n            return\r\n\r\n        # Initialize the build task queue\r\n        self._init_queue(install_deps, install_package)\r\n\r\n        # Proceed with the installation\r\n        while self.build_pq:\r\n            task = self._pop_task()\r\n            if task is None:\r\n                continue\r\n\r\n            pkg, spec = task.pkg, task.pkg.spec\r\n            pkg_id = package_id(pkg)\r\n            tty.verbose('Processing {0}: task={1}'.format(pkg_id, task))\r\n\r\n            # Ensure that the current spec has NO uninstalled dependencies,\r\n            # which is assumed to be reflected directly in its priority.\r\n            #\r\n            # If the spec has uninstalled dependencies, then there must be\r\n            # a bug in the code (e.g., priority queue or uninstalled\r\n            # dependencies handling).  So terminate under the assumption that\r\n            # all subsequent tasks will have non-zero priorities or may be\r\n            # dependencies of this task.\r\n            if task.priority != 0:\r\n                tty.error('Detected uninstalled dependencies for {0}: {1}'\r\n                          .format(pkg_id, task.uninstalled_deps))\r\n                dep_str = 'dependencies' if task.priority > 1 else 'dependency'\r\n                raise InstallError(\r\n                    'Cannot proceed with {0}: {1} uninstalled {2}: {3}'\r\n                    .format(pkg_id, task.priority, dep_str,\r\n                            ','.join(task.uninstalled_deps)))\r\n\r\n            # Skip the installation if the spec is not being installed locally\r\n            # (i.e., if external or upstream) BUT flag it as installed since\r\n            # some package likely depends on it.\r\n            if pkg_id != self.pkg_id:\r\n                not_local = _handle_external_and_upstream(pkg, False)\r\n                if not_local:\r\n                    self._update_installed(task)\r\n                    _print_installed_pkg(pkg.prefix)\r\n                    continue\r\n\r\n            # Flag a failed spec.  Do not need an (install) prefix lock since\r\n            # assume using a separate (failed) prefix lock file.\r\n            if pkg_id in self.failed or spack.store.db.prefix_failed(spec):\r\n                tty.warn('{0} failed to install'.format(pkg_id))\r\n                self._update_failed(task)\r\n\r\n                if fail_fast:\r\n                    raise InstallError(fail_fast_err)\r\n\r\n                continue\r\n\r\n            # Attempt to get a write lock.  If we can't get the lock then\r\n            # another process is likely (un)installing the spec or has\r\n            # determined the spec has already been installed (though the\r\n            # other process may be hung).\r\n            ltype, lock = self._ensure_locked('write', pkg)\r\n            if lock is None:\r\n                # Attempt to get a read lock instead.  If this fails then\r\n                # another process has a write lock so must be (un)installing\r\n                # the spec (or that process is hung).\r\n                ltype, lock = self._ensure_locked('read', pkg)\r\n\r\n            # Requeue the spec if we cannot get at least a read lock so we\r\n            # can check the status presumably established by another process\r\n            # -- failed, installed, or uninstalled -- on the next pass.\r\n            if lock is None:\r\n                self._requeue_task(task)\r\n                continue\r\n\r\n            # Determine state of installation artifacts and adjust accordingly.\r\n            self._prepare_for_install(task, keep_prefix, keep_stage,\r\n                                      restage)\r\n\r\n            # Flag an already installed package\r\n            if pkg_id in self.installed:\r\n                # Downgrade to a read lock to preclude other processes from\r\n                # uninstalling the package until we're done installing its\r\n                # dependents.\r\n                ltype, lock = self._ensure_locked('read', pkg)\r\n                if lock is not None:\r\n                    self._update_installed(task)\r\n                    _print_installed_pkg(pkg.prefix)\r\n\r\n                    # It's an already installed compiler, add it to the config\r\n                    if task.compiler:\r\n                        spack.compilers.add_compilers_to_config(\r\n                            spack.compilers.find_compilers([pkg.spec.prefix]))\r\n\r\n                else:\r\n                    # At this point we've failed to get a write or a read\r\n                    # lock, which means another process has taken a write\r\n                    # lock between our releasing the write and acquiring the\r\n                    # read.\r\n                    #\r\n                    # Requeue the task so we can re-check the status\r\n                    # established by the other process -- failed, installed,\r\n                    # or uninstalled -- on the next pass.\r\n                    self.installed.remove(pkg_id)\r\n                    self._requeue_task(task)\r\n                continue\r\n\r\n            # Having a read lock on an uninstalled pkg may mean another\r\n            # process completed an uninstall of the software between the\r\n            # time we failed to acquire the write lock and the time we\r\n            # took the read lock.\r\n            #\r\n            # Requeue the task so we can check the status presumably\r\n            # established by the other process -- failed, installed, or\r\n            # uninstalled -- on the next pass.\r\n            if ltype == 'read':\r\n                self._requeue_task(task)\r\n                continue\r\n\r\n            # Proceed with the installation since we have an exclusive write\r\n            # lock on the package.\r\n            try:\r\n                self._install_task(task, **kwargs)\r\n                self._update_installed(task)\r\n\r\n                # If we installed then we should keep the prefix\r\n                stop_before_phase = getattr(pkg, 'stop_before_phase', None)\r\n                last_phase = getattr(pkg, 'last_phase', None)\r\n                keep_prefix = keep_prefix or \\\r\n                    (stop_before_phase is None and last_phase is None)\r\n\r\n            except spack.directory_layout.InstallDirectoryAlreadyExistsError:\r\n                tty.debug(\"Keeping existing install prefix in place.\")\r\n                self._update_installed(task)\r\n                raise\r\n\r\n            except KeyboardInterrupt as exc:\r\n                # The build has been terminated with a Ctrl-C so terminate.\r\n                err = 'Failed to install {0} due to {1}: {2}'\r\n                tty.error(err.format(pkg.name, exc.__class__.__name__,\r\n                          str(exc)))\r\n                raise\r\n\r\n            except (Exception, SystemExit) as exc:\r\n                # Best effort installs suppress the exception and mark the\r\n                # package as a failure UNLESS this is the explicit package.\r\n                err = 'Failed to install {0} due to {1}: {2}'\r\n                tty.error(err.format(pkg.name, exc.__class__.__name__,\r\n                          str(exc)))\r\n\r\n                self._update_failed(task, True, exc)\r\n\r\n                if fail_fast:\r\n                    # The user requested the installation to terminate on\r\n                    # failure.\r\n                    raise InstallError('{0}: {1}'\r\n                                       .format(fail_fast_err, str(exc)))\r\n\r\n                if pkg_id == self.pkg_id:\r\n                    raise\r\n\r\n            finally:\r\n                # Remove the install prefix if anything went wrong during\r\n                # install.\r\n                if not keep_prefix:\r\n                    pkg.remove_prefix()\r\n\r\n                # The subprocess *may* have removed the build stage. Mark it\r\n                # not created so that the next time pkg.stage is invoked, we\r\n                # check the filesystem for it.\r\n                pkg.stage.created = False\r\n\r\n            # Perform basic task cleanup for the installed spec to\r\n            # include downgrading the write to a read lock\r\n            self._cleanup_task(pkg)\r\n\r\n        # Cleanup, which includes releasing all of the read locks\r\n        self._cleanup_all_tasks()\r\n\r\n        # Ensure we properly report if the original/explicit pkg is failed\r\n        if self.pkg_id in self.failed:\r\n            msg = ('Installation of {0} failed.  Review log for details'\r\n                   .format(self.pkg_id))\r\n>           raise InstallError(msg)\r\nE           spack.installer.InstallError: Installation of a failed.  Review log for details\r\n\r\nlib/spack/spack/installer.py:1597: InstallError\r\n========================================================================================== 1 failed in 2.25 seconds ==========================================================================================\r\n</pre>\r\n\r\n### Information on your system\r\n\r\n* **Spack:** 0.15.0-34-f73f9494b\r\n* **Python:** 3.6.8\r\n* **Platform:** linux-centos8-thunderx2\r\n\r\n### Additional information\r\n\r\n<!-- These boxes can be checked by replacing [ ] with [x] or by clicking them after submitting the issue. -->\r\n- [x] I have run `spack debug report` and reported the version of Spack/Python/Platform\r\n- [x] I have searched the issues of this repo and believe this is not a duplicate\r\n- [ ] I have run the failing commands in debug mode and reported the output\r\n\r\n<!-- We encourage you to try, as much as possible, to reduce your problem to the minimal example that still reproduces the issue. That would help us a lot in fixing it quickly and effectively!\r\n\r\nIf you want to ask a question about the tool (how to use it, what it can currently do, etc.), try the `#general` channel on our Slack first. We have a welcoming community and chances are you'll get your reply faster and without opening an issue.\r\n\r\nOther than that, thanks for taking the time to contribute to Spack! -->\r\n",
    "performed_via_github_app": null
}