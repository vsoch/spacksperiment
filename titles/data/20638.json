{
    "url": "https://api.github.com/repos/spack/spack/issues/20638",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/20638/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/20638/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/20638/events",
    "html_url": "https://github.com/spack/spack/pull/20638",
    "id": 777162646,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTQ3NTI3NDI0",
    "number": 20638,
    "title": "concretizer: convert virtuals to facts and move all rules to `concretize.lp`",
    "user": {
        "login": "tgamblin",
        "id": 299842,
        "node_id": "MDQ6VXNlcjI5OTg0Mg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/299842?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tgamblin",
        "html_url": "https://github.com/tgamblin",
        "followers_url": "https://api.github.com/users/tgamblin/followers",
        "following_url": "https://api.github.com/users/tgamblin/following{/other_user}",
        "gists_url": "https://api.github.com/users/tgamblin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/tgamblin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/tgamblin/subscriptions",
        "organizations_url": "https://api.github.com/users/tgamblin/orgs",
        "repos_url": "https://api.github.com/users/tgamblin/repos",
        "events_url": "https://api.github.com/users/tgamblin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/tgamblin/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 446623646,
            "node_id": "MDU6TGFiZWw0NDY2MjM2NDY=",
            "url": "https://api.github.com/repos/spack/spack/labels/concretization",
            "name": "concretization",
            "color": "006b75",
            "default": false,
            "description": null
        },
        {
            "id": 456121338,
            "node_id": "MDU6TGFiZWw0NTYxMjEzMzg=",
            "url": "https://api.github.com/repos/spack/spack/labels/refactoring",
            "name": "refactoring",
            "color": "f28f2a",
            "default": false,
            "description": null
        }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2021-01-01T00:06:57Z",
    "updated_at": "2021-01-04T22:51:12Z",
    "closed_at": "2021-01-04T22:51:11Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "pull_request": {
        "url": "https://api.github.com/repos/spack/spack/pulls/20638",
        "html_url": "https://github.com/spack/spack/pull/20638",
        "diff_url": "https://github.com/spack/spack/pull/20638.diff",
        "patch_url": "https://github.com/spack/spack/pull/20638.patch"
    },
    "body": "This converts the virtual handling in the new concretizer from already-ground rules to facts. This is the last thing that needs to be refactored, and it converts the entire concretizer to just use facts.\r\n\r\nThe previous way of handling virtuals hinged on rules involving `single_provider_for` facts that were tied to the virtual and a version range. The new method uses the condition pattern we've been using for dependencies, externals, and conflicts.\r\n\r\nTo handle virtuals as conditions, we impose constraints on \"fake\" virtual specs in the logic program. i.e., `version_satisfies(\"mpi\", \"2.0:\", \"2.0\")` is legal whereas before we wouldn't have seen something like\r\nthis. Currently, constriants are only handled on versions -- we don't handle variants or anything else yet, but they key change here is that we *could*. For a long time, virtual handling in Spack has only dealt with versions, and we'd like to be able to handle variants as well. We could easily add an integrity constraint to handle variants like the one we use for versions.\r\n\r\nThis is what the new logic looks like:\r\n\r\n```prolog\r\ndependency_conditions_hold(ID, Package, Virtual) :-\r\n  attr(Name, Arg1)             : required_provider_condition(ID, Name, Arg1);\r\n  attr(Name, Arg1, Arg2)       : required_provider_condition(ID, Name, Arg1, Arg2);\r\n  attr(Name, Arg1, Arg2, Arg3) : required_provider_condition(ID, Name, Arg1, Arg2, Arg3);\r\n  virtual_node(Virtual);\r\n  provider_condition(ID, Package, Virtual).\r\n```\r\n\r\nWhat this does is a bit confusing -- the conditions are evaluated on the provider, and they're *imposed* like dependency conditions.  Provider conditions declare `imposed_dependency_condition` like conditional dependencies, and they rely on the same rules to enforce the imposed constraints:\r\n\r\n```prolog\r\nattr(Name, Arg1, Arg2) :-\r\n  dependency_conditions_hold(ID, Package, Dependency),\r\n  imposed_dependency_condition(ID, Name, Arg1, Arg2).\r\n\r\nattr(Name, Arg1, Arg2, Arg3) :-\r\n  dependency_conditions_hold(ID, Package, Dependency),\r\n  imposed_dependency_condition(ID, Name, Arg1, Arg2, Arg3).\r\n```",
    "performed_via_github_app": null
}