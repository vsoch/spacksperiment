{
    "url": "https://api.github.com/repos/spack/spack/issues/14609",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/14609/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/14609/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/14609/events",
    "html_url": "https://github.com/spack/spack/issues/14609",
    "id": 554280309,
    "node_id": "MDU6SXNzdWU1NTQyODAzMDk=",
    "number": 14609,
    "title": "Update package submodules conditionally based on variant",
    "user": {
        "login": "tjfulle",
        "id": 1564391,
        "node_id": "MDQ6VXNlcjE1NjQzOTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1564391?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tjfulle",
        "html_url": "https://github.com/tjfulle",
        "followers_url": "https://api.github.com/users/tjfulle/followers",
        "following_url": "https://api.github.com/users/tjfulle/following{/other_user}",
        "gists_url": "https://api.github.com/users/tjfulle/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/tjfulle/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/tjfulle/subscriptions",
        "organizations_url": "https://api.github.com/users/tjfulle/orgs",
        "repos_url": "https://api.github.com/users/tjfulle/repos",
        "events_url": "https://api.github.com/users/tjfulle/events{/privacy}",
        "received_events_url": "https://api.github.com/users/tjfulle/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 73908756,
            "node_id": "MDU6TGFiZWw3MzkwODc1Ng==",
            "url": "https://api.github.com/repos/spack/spack/labels/feature",
            "name": "feature",
            "color": "84b6eb",
            "default": false,
            "description": null
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 0,
    "created_at": "2020-01-23T16:51:45Z",
    "updated_at": "2020-01-23T17:15:00Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "Packages should be able to update submodules conditionally, based on variants.\r\n\r\n### Rationale\r\n\r\nSome packages have many submodules, some very large (eg, test suites).  Not all package variants will need all submodules.  But, spack's current submodule approach is to update all submodules, unconditionally.  In my particular case, we have several submodules, each > 10 Gb, that are optional.\r\n\r\nIt is possible to add a function to a package that updates the package's submodules and decorate that function with `run_before` or `run_after`, eg\r\n\r\n```python\r\n@run_before(\"cmake\")\r\ndef update_submodules(self):\r\n    with working_dir(self.stage.source_path):\r\n        if \"+variant-a\" in self.spec:\r\n            git(\"submodule\", \"update\", \"variant-a\")\r\n        ...\r\n```\r\n\r\nThe problem is, this function will not be called by `spack mirror ...` or `spack fetch`.  I put in the following hack that does what I need, but a native spack solution would be best.\r\n\r\n```python\r\nclass MyPackage(CMakePackage):\r\n   ...\r\n    def _make_stage(self):\r\n        stage = super(MyPackage, self)._make_stage()\r\n        assert isinstance(stage, StageComposite)\r\n        assert isinstance(stage[0], Stage)\r\n        # monkey-patch the stage's fetch method to use ours\r\n        stage[0].fetch = my_fetch(self).__get__(stage[0], Stage)\r\n        return stage\r\n\r\n    def update_submodules(self):\r\n        with working_dir(self.stage.source_path):\r\n            git_submodule = Executable(\"git submodule\")\r\n            git_submodule(\"init\")\r\n            if \"+variant-a\" in self.spec:\r\n                git_submodule(\"update\", \"variant-a\")\r\n            if \"variant-b\" in self.spec:\r\n                git_submodule(\"update\", \"variant-b\")\r\n\r\n\r\ndef my_fetch(package):\r\n    def fetch(stage, mirror_only=False):\r\n        Stage.fetch(stage, mirror_only=mirror_only)\r\n        package.update_submodules()\r\n    return fetch\r\n```",
    "performed_via_github_app": null
}