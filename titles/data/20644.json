{
    "url": "https://api.github.com/repos/spack/spack/issues/20644",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/20644/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/20644/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/20644/events",
    "html_url": "https://github.com/spack/spack/pull/20644",
    "id": 777588992,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTQ3ODQzNDA4",
    "number": 20644,
    "title": "concretizer: unify logic for spec conditionals",
    "user": {
        "login": "tgamblin",
        "id": 299842,
        "node_id": "MDQ6VXNlcjI5OTg0Mg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/299842?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tgamblin",
        "html_url": "https://github.com/tgamblin",
        "followers_url": "https://api.github.com/users/tgamblin/followers",
        "following_url": "https://api.github.com/users/tgamblin/following{/other_user}",
        "gists_url": "https://api.github.com/users/tgamblin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/tgamblin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/tgamblin/subscriptions",
        "organizations_url": "https://api.github.com/users/tgamblin/orgs",
        "repos_url": "https://api.github.com/users/tgamblin/repos",
        "events_url": "https://api.github.com/users/tgamblin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/tgamblin/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 446623646,
            "node_id": "MDU6TGFiZWw0NDY2MjM2NDY=",
            "url": "https://api.github.com/repos/spack/spack/labels/concretization",
            "name": "concretization",
            "color": "006b75",
            "default": false,
            "description": null
        },
        {
            "id": 456121338,
            "node_id": "MDU6TGFiZWw0NTYxMjEzMzg=",
            "url": "https://api.github.com/repos/spack/spack/labels/refactoring",
            "name": "refactoring",
            "color": "f28f2a",
            "default": false,
            "description": null
        }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 4,
    "created_at": "2021-01-03T07:24:16Z",
    "updated_at": "2021-03-16T11:50:16Z",
    "closed_at": "2021-03-16T11:50:15Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "pull_request": {
        "url": "https://api.github.com/repos/spack/spack/pulls/20644",
        "html_url": "https://github.com/spack/spack/pull/20644",
        "diff_url": "https://github.com/spack/spack/pull/20644.diff",
        "patch_url": "https://github.com/spack/spack/pull/20644.patch"
    },
    "body": "Depends on #20638, which should go in first.\r\n\r\nThis builds on #20638 by unifying all the places in the concretizer where things are conditional on specs.  Previously, we duplicated a common spec conditional pattern for dependencies, virtual providers, conflicts, and externals.  That was introduced in #20423 and refined in #20507, and roughly looked as follows.\r\n\r\nGiven some directives in a package like:\r\n\r\n```python\r\ndepends_on(\"foo@1.0+bar\", when=\"@2.0+variant\")\r\nprovides(\"mpi@2:\", when=\"@1.9:\")\r\n```\r\n\r\nWe handled the `@2.0+variant` and `@1.9:` parts by generating generated `dependency_condition()`, `required_dependency_condition()`, and `imposed_dependency_condition()` facts to trigger rules like this:\r\n\r\n```prolog\r\ndependency_conditions_hold(ID, Parent, Dependency) :-\r\n  attr(Name, Arg1)             : required_dependency_condition(ID, Name, Arg1);\r\n  attr(Name, Arg1, Arg2)       : required_dependency_condition(ID, Name, Arg1, Arg2);\r\n  attr(Name, Arg1, Arg2, Arg3) : required_dependency_condition(ID, Name, Arg1, Arg2, Arg3);\r\n  dependency_condition(ID, Parent, Dependency);\r\n  node(Parent).\r\n```\r\n\r\nAnd we handled `foo@1.0+bar` and `mpi@2:` parts (\"imposed constraints\") like this:\r\n\r\n```prolog\r\nattr(Name, Arg1, Arg2) :-\r\n  dependency_conditions_hold(ID, Package, Dependency),\r\n  imposed_dependency_condition(ID, Name, Arg1, Arg2).\r\n\r\nattr(Name, Arg1, Arg2, Arg3) :-\r\n  dependency_conditions_hold(ID, Package, Dependency),\r\n  imposed_dependency_condition(ID, Name, Arg1, Arg2, Arg3).\r\n```\r\n\r\nThese rules were repeated with different input predicates for requirements (e.g., `required_dependency_condition`) and imposed constraints (e.g., `imposed_dependency_condition`) throughout `concretize.lp`. In #20638 it got to be a bit confusing, because we used the same `dependency_condition_holds` predicate to impose constraints on conditional dependencies and virtual providers. So, even though the pattern was repeated, some of the conditional rules were conjoined in a weird way.\r\n\r\nInstead of repeating this pattern everywhere, we now have *one* set of consolidated rules for conditions:\r\n\r\n```prolog\r\ncondition_holds(ID) :-\r\n  condition(ID);\r\n  attr(Name, A1)         : condition_requirement(ID, Name, A1);\r\n  attr(Name, A1, A2)     : condition_requirement(ID, Name, A1, A2);\r\n  attr(Name, A1, A2, A3) : condition_requirement(ID, Name, A1, A2, A3).\r\n\r\nattr(Name, A1)         :- condition_holds(ID), imposed_constraint(ID, Name, A1).\r\nattr(Name, A1, A2)     :- condition_holds(ID), imposed_constraint(ID, Name, A1, A2).\r\nattr(Name, A1, A2, A3) :- condition_holds(ID), imposed_constraint(ID, Name, A1, A2, A3).\r\n```\r\n\r\nthis allows us to use `condition(ID)` and `condition_holds(ID)` to encapsulate the conditional logic on specs in all the scenarios where we need it.  Instead of defining predicates for the requirements and imposed constraints, we generate the condition inputs with generic facts, and define predicates to associate the condition ID with a particular scenario.  So, now, the generated facts for a condition look like this:\r\n\r\n```prolog\r\ncondition(121).                                                                          \r\ncondition_requirement(121,\"node\",\"cairo\").                                               \r\ncondition_requirement(121,\"variant_value\",\"cairo\",\"fc\",\"True\").                          \r\nimposed_constraint(121,\"version_satisfies\",\"fontconfig\",\"2.10.91:\").                     \r\ndependency_condition(121,\"cairo\",\"fontconfig\").                                          \r\ndependency_type(121,\"build\").                                                            \r\ndependency_type(121,\"link\").  \r\n```\r\n\r\nThe requirements and imposed constraints are generic, and we associate them with their meaning via the id.  Here, `dependency_condition(121,  \"cairo\", \"fontconfig\")` tells us that condition 121 has to do with the dependency of `cairo` on `fontconfig`, and the conditional dependency rules just become:\r\n\r\n```prolog\r\ndependency_holds(Package, Dependency, Type) :-\r\n  dependency_condition(ID, Package, Dependency),\r\n  dependency_type(ID, Type),\r\n  condition_holds(ID).\r\n```\r\n\r\nDependencies, virtuals, conflicts, and externals all now use similar patterns, and the logic for generating condition facts is common to all of them on the python side, as well.  The more specific routines like `package_dependencies_rules` just call `self.condition(...)` to get an id and generate requirements and imposed constraints, then they generate their extra facts wth the returned id, like this:\r\n\r\n```python\r\n    def package_dependencies_rules(self, pkg, tests):\r\n        \"\"\"Translate 'depends_on' directives into ASP logic.\"\"\"\r\n        for _, conditions in sorted(pkg.dependencies.items()):\r\n            for cond, dep in sorted(conditions.items()):\r\n                condition_id = self.condition(cond, dep.spec, pkg.name)  # create a condition and get its id\r\n                self.gen.fact(fn.dependency_condition(  # associate specifics about the dependency w/the id\r\n                    condition_id, pkg.name, dep.spec.name\r\n                ))\r\n        # etc.\r\n```\r\n\r\n- [x] unify generation and logic for conditions\r\n- [x] use unified logic for dependencies\r\n- [x] use unified logic for virtuals\r\n- [x] use unified logic for conflicts\r\n- [x] use unified logic for externals\r\n",
    "performed_via_github_app": null
}