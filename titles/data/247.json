{
    "url": "https://api.github.com/repos/spack/spack/issues/247",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/247/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/247/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/247/events",
    "html_url": "https://github.com/spack/spack/issues/247",
    "id": 122771785,
    "node_id": "MDU6SXNzdWUxMjI3NzE3ODU=",
    "number": 247,
    "title": "SP 001: Common variant names",
    "user": {
        "login": "tgamblin",
        "id": 299842,
        "node_id": "MDQ6VXNlcjI5OTg0Mg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/299842?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tgamblin",
        "html_url": "https://github.com/tgamblin",
        "followers_url": "https://api.github.com/users/tgamblin/followers",
        "following_url": "https://api.github.com/users/tgamblin/following{/other_user}",
        "gists_url": "https://api.github.com/users/tgamblin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/tgamblin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/tgamblin/subscriptions",
        "organizations_url": "https://api.github.com/users/tgamblin/orgs",
        "repos_url": "https://api.github.com/users/tgamblin/repos",
        "events_url": "https://api.github.com/users/tgamblin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/tgamblin/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 73908756,
            "node_id": "MDU6TGFiZWw3MzkwODc1Ng==",
            "url": "https://api.github.com/repos/spack/spack/labels/feature",
            "name": "feature",
            "color": "84b6eb",
            "default": false,
            "description": null
        }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 13,
    "created_at": "2015-12-17T16:36:54Z",
    "updated_at": "2015-12-20T03:23:55Z",
    "closed_at": "2015-12-20T03:23:55Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "Proposal by @markcmiller86 \n\nThere are a number of aspects of package installation that are frequently duplicated from package to package.\n\nIn Spack parlance, these might be best considered variants. However, in some sense they are global variants as they effect many packages in the same way.\n\nI'd like to start a list of these here and keep track of this. Here's a start. Also, would like to keep variant tags short so here we try to use just 3-character variant names.\n## debug/optimized\n- `+opt` means to build optimized (production) -O3, etc. (default)\n- `-opt` means to build a package with (maximal) debugging features enabled (e.g. -g, -DNDEBUG, etc., maybe special profiling features enabled, etc.). Note that currently Spack automatically sets standard CMake switches to include CMAKE_BUILD_TYPE=RelWithDebInfo. That practice would be replaced with this new way of handling this as a variant (though the proposed variant in fact does not deal with the subtle RelWithDebInfo flavor)\n## static/dynamic libraries\n- `+dyn` means to build both dynamic and static libraries in the install point\n- `-dyn` means to build only static (default)\n## 32bit/64bit\n- `+b64` means to build both 32 and 64 bit libraries (default)\n- `-b64` means to build only 32 bit\n## Interface Languages (fortran/cxx/c\u2026)\n- `+fort` means to build (all) fortran interfaces (where available) when fc compiler is specified (default)\n- `+cxx` means to build C++ interfaces (where available) when cxx compiler is specified\n- `+c` means to build C interfaces (default)\n- `+pyth' means build python interfaces (where available) if python is also available\n\nNote that C/CXX interface variant switches may be less relevant as typically whenever you have a C compiler, you also have a C++ compiler. The same hasn't always tended to be true for Fortran though (OS X for example) and so having that variant switch is important. OTOH, maybe specifying a fortran compiler is sufficient cause to enable fortran wherever its possible and all three of these variant switches can be argued away.\n## serial/parallel\n- `+par` means to build both serial and parallel variants (default)\n- `-par` means to build only serial variant\n\nIn a context where the only parallelism comes from MPI, this works. In a context where there are multiple forms of parallelism (threads, mpi, etc.) it gets more complicated and `parallel` may not be the appropriate moniker. Nonetheless, there are a lot of libraries out there that are designed to work in serial and (MPI) parallel. More thought is required here.\n## Libraries, Tools, Tests/Checks and Examples\n- `+test` means to both build and run tests as part of installation (failing the installation if tests don't pass), default=False\n- `-tools` means to NOT build/install support tools (for example, for HDF5, I don't wanna build/install support tools like h5ls on compute nodes, only for login nodes)\n- `+examples` means to build/install examples\n## Other switches since starting this page\n- handling of -PIC, -fPIC, -qpic and variants ([already have a post in google groups about this](https://groups.google.com/forum/#!topic/spack/7brRuR0v6O4)). Its essential if the package you are building will ever be intended to be used in the creation of shared object (.so).\n## Variants for dependent libraries\n\nIn my experience, there are basically two kinds of dependent libraries for a package; _required_ and _optional_. Required dependencies are already addressed by Spack and do not involve the use of variants. But, what about variants for optional dependencies? One possibility is to have a package support each such dependency as a variant. But, that seems like it could potentially get unwieldly. This is especially true if the dependency has the potential to ripple down through the dependency graph. Furthermore, with different packages possibly having different optional dependencies, a single spack command-line to build a given package could wind up getting quite long due to package-specific optional dependency variants. Is there any Spack shorthand we can develop to simplify this a bit and perhaps come up with a set of global variants that nonetheless help to specify how optional dependencies in any given package be handled?\n\nWhat are the downsides of simply treating all optional dependencies as required? In other words, what if we opted to _maximize_ optional dependencies? Well, in a nutshell, its less robust; since more things are being built, there is more chance of a failure either to build or to access a given package on the network; an application linking to the desired package must link more packages into the same executable and maybe not all the packages play well together; some packages are optional because they represent experimental capability that is not fully tested and/or works in limited contexts (e.g. compilers, MPI implementations, etc.). So, there are good reasons for Spack to, by default, _minimize_ optional dependencies.\n\nWhat are the downsides to minimizing optional dependencies? The key downside is that needed functionality isn't available in a given package requiring that package and possibly some portion of its dependencies to be re-built. As different users in a HPC stack install Spack is managing encounter the need for different combinations of optional dependent libraries, eventually that installation could wind up getting populated with the combinatoric expansion of all possible combinations of optional dependencies. Though Spack is designed to handle this situation, is it really an outcome we want to design towards?\n\nLets propose the following global variants for handling optional dependent packages\n- variant('reqdep', default=False, 'Minimize dependencies. Build only with required dependent libraries')\n- variant('stddep', defualt=True, 'Standard dependencies. Build with standard/common optional dependent libraries.')\n- variant('alldep', default=False, 'Maximal dependencies. Build with all possible dependent libraries')\n\nThe meaning of _reqdep_ should be obvious. It means to turn off _all_ optional dependent libraries and build _only_ with required dependent libraries. The meaning of _stddep_ means to build the package in its _standard_ or _common_ configuration with those optional libraries the packages that the package is commonly used with. Furthermore, I am proposing this as the default. What constitutes the set of standard or common optional dependent packages can be determined on a package-specific basis. For example, the Silo library is commonly used with the HDF5 library so activation of the HDF5 dependency in Silo will occur by default but can be turned off by setting the variant '+reqdep'.\n\nThese are sort of mutually exclusive options in that setting one has implications for the others. It would be nicer to have a 3-value variant such as\n- variant('optdeps', values=['off':'Minimize dependencies. Build only with required dependent libraries',\n                        'std':'Standard dependencies. Build with standard/common optional dependent libraries.',\n                        'all':'Maximal dependencies. Build with all possible dependent libraries']\n\n```\n```\n",
    "performed_via_github_app": null
}