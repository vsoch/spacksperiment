{
    "url": "https://api.github.com/repos/spack/spack/issues/13115",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/13115/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/13115/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/13115/events",
    "html_url": "https://github.com/spack/spack/issues/13115",
    "id": 504956343,
    "node_id": "MDU6SXNzdWU1MDQ5NTYzNDM=",
    "number": 13115,
    "title": "Rework the pipeline workflow",
    "user": {
        "login": "scottwittenburg",
        "id": 6527504,
        "node_id": "MDQ6VXNlcjY1Mjc1MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6527504?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/scottwittenburg",
        "html_url": "https://github.com/scottwittenburg",
        "followers_url": "https://api.github.com/users/scottwittenburg/followers",
        "following_url": "https://api.github.com/users/scottwittenburg/following{/other_user}",
        "gists_url": "https://api.github.com/users/scottwittenburg/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/scottwittenburg/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/scottwittenburg/subscriptions",
        "organizations_url": "https://api.github.com/users/scottwittenburg/orgs",
        "repos_url": "https://api.github.com/users/scottwittenburg/repos",
        "events_url": "https://api.github.com/users/scottwittenburg/events{/privacy}",
        "received_events_url": "https://api.github.com/users/scottwittenburg/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 1491155556,
            "node_id": "MDU6TGFiZWwxNDkxMTU1NTU2",
            "url": "https://api.github.com/repos/spack/spack/labels/ci",
            "name": "ci",
            "color": "9891e0",
            "default": false,
            "description": "Issues related to Continuous Integration"
        },
        {
            "id": 73908756,
            "node_id": "MDU6TGFiZWw3MzkwODc1Ng==",
            "url": "https://api.github.com/repos/spack/spack/labels/feature",
            "name": "feature",
            "color": "84b6eb",
            "default": false,
            "description": null
        },
        {
            "id": 1491156024,
            "node_id": "MDU6TGFiZWwxNDkxMTU2MDI0",
            "url": "https://api.github.com/repos/spack/spack/labels/pipelines",
            "name": "pipelines",
            "color": "b22353",
            "default": false,
            "description": "Issues related to spack's pipeline features"
        },
        {
            "id": 1638959676,
            "node_id": "MDU6TGFiZWwxNjM4OTU5Njc2",
            "url": "https://api.github.com/repos/spack/spack/labels/radiuss",
            "name": "radiuss",
            "color": "284fa3",
            "default": false,
            "description": ""
        }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 16,
    "created_at": "2019-10-10T00:04:00Z",
    "updated_at": "2020-06-10T16:47:22Z",
    "closed_at": null,
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "body": "## Introduction\r\n\r\nIn order to make the Gitlab CI pipeline easier to adopt and simpler to implement, we have begun work on an \"inversion\" of the current workflow.  Currently, the spack repo (or a gitlab mirror thereof) is the starting point, and when CI is kicked off on that repo, a custom environment repository (specified in CI environment variables) is cloned.  To \"invert\" that workflow would mean to make the environment repository the starting point, and when CI is kicked off on _that_ repo, a possible (but not necessarily requisite) first step would be to clone some custom spack repository.  In either view of the workflow, a `.gitlab-ci.yml` is generated and pushed to a downstream CI repository where the build jobs of the main pipeline are run.\r\n\r\nThe reason for creating this issue is to provide a place to have a conversation regarding this work while it is still in progress, giving adopters a chance to provide feedback/input on the proposed changes.  So please feel free to comment on this issue with your thoughts and suggestions.\r\n\r\n### Rationale\r\n\r\nHere's how this new workflow might look from the perspective of an as-yet unwritten \u201cQuickstart Guide to Spack Pipelines\u201d to look:\r\n\r\n1. Create a repository on your gitlab instance\r\n2. Add a spack.yaml at the root containing your pipeline environment\r\n3. Add a .gitlab-ci.yml at the root containing a single job, similar to this one:\r\n\r\n```\r\n  pipeline-job:\r\n    tags:\r\n      - <custom-tag>\r\n      ...\r\n    script:\r\n      - spack ci start\r\n```\r\n\r\n4. Add any secrets required by the CI process to environment variables using the CI web ui\r\n\r\nWe'll refer to that example above throughout this issue description.  The first thing to notice is that we're not forcing users to track any specific upstream spack repo.  In some cases, it could be the case that any runners tagged to match the tags in the job will already have a default spack instance that should be used.  In the job example above, the assumption is that on the runners identified by `<custom-tags>, ...`, the appropriate version of spack will already be loaded and ready to use.  In cases where a custom spack is needed, that information will need to be specified when generating the workload, as well as propagated to all build jobs, and thus a pipeline job like the following might be needed:\r\n\r\n```\r\n  pipeline-job:\r\n    tags:\r\n      - <some-other-tag>\r\n      ...\r\n    before_script:\r\n      - pushd <some_temp_dir>\r\n      - git clone ${SPACK_REPO} --branch ${SPACK_REF}\r\n      - popd\r\n      - . <some_temp_dir>/spack/share/spack/setup-env.sh\r\n    script:\r\n      - spack ci start ... --spack-repo ${SPACK_REPO} --spack-ref ${SPACK_REF}\r\n```\r\n\r\n### Description\r\n\r\nAdding this feature doesn't necessarily require a large re-implementation of the pipeline functionality we have currently.  Instead, it represents a change in the way we think about things, it moves some responsibility and control around, and it requires that we do some work to re-organize things.  Some tradeoffs are inevitable, one example is that instead of needing to clone some custom environment repository in order to find the release environment packages we want to build, we may instead need to clone a custom spack repo as a par of the workflow.  In this case, we put some responsibility (control) in the hands of pipeline adopters to know what spack they want to use in their environment.  Also in this case, it requires that the pipeline infrastructure generates jobs with the ability to clone a custom spack.  Some other tradeoffs are discussed in the sections below.\r\n\r\n### Triggering pipelines (also related to PR testing)\r\n\r\nThere are two broad cases of pipeline triggering that we are keeping in mind:\r\n\r\n1. Responding to changes on the spack repo itself.  This could include pushing to a particular branch or creating a PR (including from a fork).\r\n2. Responding to changes on the environment repo (which must necessarily be a gitlab repo if we wish to take advantage of gitlab CI)\r\n\r\nAll sub-cases of case 1, above, may need to be handled by sending API requests to the gitlab environment repo where pipelines originate.  We will consider the possibilities of using GitHub actions (or similar functionality) to send the API requests to gitlab.  We need to investigate how much flexibility we have on the gitlab side, in terms of dynamically controlling aspects of the pipeline using variables in the request.\r\n\r\nCases falling under 2, above, may be simpler to trigger pipelines on the same repo where the environment is housed.  While multiple repositories are still required (see the next section), gitlab [multi-project pipelines](https://docs.gitlab.com/ee/ci/multi_project_pipelines.html) could be leveraged to handle the triggering between the pre-ci and downstream CI repos.\r\n\r\nThe tradeoff here is fairly symmetric: it becomes potentially easier to test PRs to the environment repository, at the expense of complicating PR testing on spack itself.\r\n\r\n### Effect on the number of repositories required for pipeline testing\r\n\r\nUntil now (in fact, until at least January 2020) Gitlab CI has not provided the ability to generate jobs dynamically, and our workaround for this has been to use multiple gitlab repositories.  One repository, which we have called the \"pre-ci\" repository (and which has always been a mirror of the spack repo itself), is used to generate the workload for a second repository which we have called the \"downstream ci\" repository.  A third repository, which we have called the environment repository, was introduced as a way for pipeline adopters to specify their own custom environment. \r\n\r\n Adopting this new way of thinking of the workflow would certainly allow us to get rid of one of these repos, the spack mirror.  At that point the environment repository would become the \"pre-ci\" repo and the \"downstream ci\" repo could remain unchanged.  When gitlab provides the ability to generate jobs dynamically (as described [here](https://gitlab.com/gitlab-org/gitlab-foss/issues/45828)), we could get rid of the downstream ci repo as well, resulting in just a single repo for build pipelines.  Additionally, at that point the jobs shown above would be replaced with the \"seed job\" (which could possibly just invoke `spack ci generate`).\r\n\r\nThe obvious tradeoff of \"inverting the workflow\" here is that adopters do not need to track upstream spack in any way, and instead of most (if not all) workflows needing to clone a custom environment, now some workflows will need to clone spack (although some will not).\r\n\r\n### To-Do List\r\n\r\nThings that will need to be done in order to implement this:\r\n\r\n- [ ] Create a new `spack ci` command with a set of useful sub-commands (some converted from existing bash scripts):\r\n  * `spack ci start` (as shown in the example above) This would be some kind of meta command that would trigger the whole pipeline process to begin.\r\n  * `spack ci generate` could be invoked by `spack ci start` and would generate the `.gitlab-ci.yml`  (work in progress [here](https://github.com/spack/spack/pull/12854))\r\n  * `spack ci push` could also be invoked by `spack ci start` and would commit/push the generated file to the downstream CI repo (work in progress [here](https://github.com/spack/spack/pull/12854))\r\n  * `spack ci rebuild` would be invoked within the `script` section of a generated build job (work in progress [here](https://github.com/scottwittenburg/spack/tree/rebuild-pkg-to-spack-cmd-take-two))\r\n- [ ] Investigate the various possible means of triggering pipelines, especially using arbitrary variables, as documented [here](https://docs.gitlab.com/ee/ci/triggers/#making-use-of-trigger-variables)\r\n- [ ] Using the `spack-infrastructure` repo, experiment with and document how pipelines can be achieved for the various expected use-cases:\r\n  * release testing for spack repo itself (a spack repo contains the environment file)\r\n  * pipelins for sites\r\n    ** where spack is already installed and available on runners\r\n    ** where some version of spack needs to be cloned",
    "performed_via_github_app": null
}