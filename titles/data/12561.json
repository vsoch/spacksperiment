{
    "url": "https://api.github.com/repos/spack/spack/issues/12561",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/12561/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/12561/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/12561/events",
    "html_url": "https://github.com/spack/spack/pull/12561",
    "id": 484737320,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MzEwNTU0MTM5",
    "number": 12561,
    "title": "Support yaml paths anywhere specs are handled on CLI",
    "user": {
        "login": "scottwittenburg",
        "id": 6527504,
        "node_id": "MDQ6VXNlcjY1Mjc1MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6527504?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/scottwittenburg",
        "html_url": "https://github.com/scottwittenburg",
        "followers_url": "https://api.github.com/users/scottwittenburg/followers",
        "following_url": "https://api.github.com/users/scottwittenburg/following{/other_user}",
        "gists_url": "https://api.github.com/users/scottwittenburg/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/scottwittenburg/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/scottwittenburg/subscriptions",
        "organizations_url": "https://api.github.com/users/scottwittenburg/orgs",
        "repos_url": "https://api.github.com/users/scottwittenburg/repos",
        "events_url": "https://api.github.com/users/scottwittenburg/events{/privacy}",
        "received_events_url": "https://api.github.com/users/scottwittenburg/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [],
    "state": "closed",
    "locked": false,
    "assignee": {
        "login": "scheibelp",
        "id": 1659704,
        "node_id": "MDQ6VXNlcjE2NTk3MDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1659704?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/scheibelp",
        "html_url": "https://github.com/scheibelp",
        "followers_url": "https://api.github.com/users/scheibelp/followers",
        "following_url": "https://api.github.com/users/scheibelp/following{/other_user}",
        "gists_url": "https://api.github.com/users/scheibelp/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/scheibelp/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/scheibelp/subscriptions",
        "organizations_url": "https://api.github.com/users/scheibelp/orgs",
        "repos_url": "https://api.github.com/users/scheibelp/repos",
        "events_url": "https://api.github.com/users/scheibelp/events{/privacy}",
        "received_events_url": "https://api.github.com/users/scheibelp/received_events",
        "type": "User",
        "site_admin": false
    },
    "assignees": [
        {
            "login": "scheibelp",
            "id": 1659704,
            "node_id": "MDQ6VXNlcjE2NTk3MDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1659704?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/scheibelp",
            "html_url": "https://github.com/scheibelp",
            "followers_url": "https://api.github.com/users/scheibelp/followers",
            "following_url": "https://api.github.com/users/scheibelp/following{/other_user}",
            "gists_url": "https://api.github.com/users/scheibelp/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/scheibelp/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/scheibelp/subscriptions",
            "organizations_url": "https://api.github.com/users/scheibelp/orgs",
            "repos_url": "https://api.github.com/users/scheibelp/repos",
            "events_url": "https://api.github.com/users/scheibelp/events{/privacy}",
            "received_events_url": "https://api.github.com/users/scheibelp/received_events",
            "type": "User",
            "site_admin": false
        }
    ],
    "milestone": null,
    "comments": 8,
    "created_at": "2019-08-23T22:36:58Z",
    "updated_at": "2019-09-18T02:45:53Z",
    "closed_at": "2019-09-18T02:45:37Z",
    "author_association": "CONTRIBUTOR",
    "active_lock_reason": null,
    "pull_request": {
        "url": "https://api.github.com/repos/spack/spack/pulls/12561",
        "html_url": "https://github.com/spack/spack/pull/12561",
        "diff_url": "https://github.com/spack/spack/pull/12561.diff",
        "patch_url": "https://github.com/spack/spack/pull/12561.patch"
    },
    "body": "This is maybe a cleaner approach to do the same thing as described in #11103.  It gets around some of the ambiguities there and allows any combination of clispecs and yaml paths, including depending on other specs by yaml path.\r\n\r\n## Notes on the approach:\r\n\r\nPaths to spec yaml files (files containing concreted specs) can come in three flavors:\r\n\r\n1. file in current directory (no relative path specifiers included e.g. `pkgconf.yaml`)\r\n2. relative path (e.g. `./pkgconf.yaml`, `../../Documents/pkgconf.yaml`, etc.)\r\n3. absolute path (`/home/me/pkgconf.yaml`, `/home/me/../me/pkgconf.yaml`, etc.)\r\n\r\n### Case 1 (relative path, current directory):\r\n  \r\nThis case collides with existing handling of namespaced specs.  Current examples like `builtin.yaml-cpp`, which need to keep working, provided some of the constraints we needed to handle.  To handle this case, we let the normal tokenization catch, e.g., `pkgconf.yaml` as an ID, which would normally be treated as a namespaced package, but now we first check if there is a file in the current directory with that name, and if that is the case, then we assume the user meant that rather than namespace `pkgconf` and package name `yaml`.\r\n\r\n### Case 2 (relative path starting with or containing \".\" and \"..\"):\r\n\r\nWe added the `DOTS` token to the lexer to notice any instances of `.` or `..` in the input.  These don't get confused with ID tokens because ID must start with a word character.  If we ever see this new token, we look ahead in the input to see if any token ends with '.yaml' and from there try to handle spec yaml path.  We allow `DOTS` to appear anywhere in the path, e.g. `../../some_directory/./pkgconf.yaml`\r\n\r\n### Case 3 (absolute paths starting with '/'):\r\n\r\nThis case collides with the existing parsing that sees `/` as the beginning of a package hash.  So the general approach we took here was to first try to treat anything after a `/` as a hash.  And only if that results in a `NoSuchHashError`, do we attempt to treat what comes next as possibly a path to a yaml file. \r\n\r\nCurrently, there were three cases where \"/<pkg-hash>\" could be expected to appear in cli input taking \"specs\":\r\n\r\n- Just referring to a root spec by hash\r\n- Some other spec depending on a spec by hash\r\n- Hash used to qualify previous spec in input (like a variant)\r\n\r\nIn all those cases, we allow spec parsing to first try to treat what comes after the '/' as a spec hash.  If the result is a `NoSuchHashError`, then we were about to bail anyway, telling the user about the bad hash.  So it seems safe to just peek ahead in the input at this point and see if what comes next could be interpreted as a path to a spec yaml file (it must end in .yaml).  If we don't find that, then we just go ahead and report the `NoSuchHashError`.  Otherwise we assume the user meant to provide a path to a yaml file, and proceed on that assumption.\r\n\r\nThe result of this is that we can now accept path to spec yaml files (but the file must be named with the .yaml extension) anywhere we could accept other types of cli specs on the command line.",
    "performed_via_github_app": null
}