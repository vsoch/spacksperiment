{
    "url": "https://api.github.com/repos/spack/spack/issues/1338",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/1338/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/1338/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/1338/events",
    "html_url": "https://github.com/spack/spack/issues/1338",
    "id": 167070856,
    "node_id": "MDU6SXNzdWUxNjcwNzA4NTY=",
    "number": 1338,
    "title": "Proposal: Spec Aliases to Handle Changing Hashes",
    "user": {
        "login": "citibeth",
        "id": 1924215,
        "node_id": "MDQ6VXNlcjE5MjQyMTU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1924215?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/citibeth",
        "html_url": "https://github.com/citibeth",
        "followers_url": "https://api.github.com/users/citibeth/followers",
        "following_url": "https://api.github.com/users/citibeth/following{/other_user}",
        "gists_url": "https://api.github.com/users/citibeth/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/citibeth/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/citibeth/subscriptions",
        "organizations_url": "https://api.github.com/users/citibeth/orgs",
        "repos_url": "https://api.github.com/users/citibeth/repos",
        "events_url": "https://api.github.com/users/citibeth/events{/privacy}",
        "received_events_url": "https://api.github.com/users/citibeth/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 466955297,
            "node_id": "MDU6TGFiZWw0NjY5NTUyOTc=",
            "url": "https://api.github.com/repos/spack/spack/labels/proposal",
            "name": "proposal",
            "color": "0e8a16",
            "default": false,
            "description": null
        }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 6,
    "created_at": "2016-07-22T15:28:03Z",
    "updated_at": "2019-12-03T10:21:03Z",
    "closed_at": "2019-12-03T10:21:02Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "@adamjstewart @tgamblin @fgeorgatos @becker33 @eschnett @mwilliammyers @davydden @alalazo \n\nThis is an alternate approach to many of the ideas suggested in #1325.  Those ideas are mainly focused on trying to avoid unnecessary rebuilds: seen as useful not just to conserve CPU cycles, but more importantly to avoid changing hashes.  While they may be useful, the ideas in #1325 are unlikely to really solve the problem because:\n1. Too many cases where Spack can't guess what to do (i.e. what to do when a new variant is added).\n2. Too many ways for a hash to change: addition of a variant, change way down in the DAG, etc.  Too hard for Spack to divine what to do in each case. \n\nThe alternative presented here is to bury hashes under another layer of indirection, so the end user does not need to be aware (or care) when they change.  This approach requires the sysadmin to be a little more mindful in how they install software; but the benefit is it allows good control over when and how end-user visible package names change or don't change.  An added benefit is it eliminates hashes from end-user view.\n\nSo here goes...\n\nSuppose I'm a supercomputer admin, and my job is to install/maintain a set of packages for users.  For each package that users want, I have a `spack install` command that installs it.  For example:\n\n```\nspack install zlib\nspack install netcdf@4.1.1~hdf5\nspack install ibmisc@0.1.2+python+netcdf ^netcdf-cxx4 ^netcdf+mpi ^eigen~suitesparse ^py-numpy+lapack ^openblas ^python@3:\n```\n\nSpack fully concretizes these specs, of course.  But _what the user typed_ (what I call the _user spec_ here) is important, since it gives clues about what the user does or does not care about.\n\nMy installation site will provide a function mapping the tuple (user spec, concretized spec) to a string.  This function is entirely arbitrary, for a given site.  For sites that want to install just one of every package@version, the function might strip out everything except a version number.  For things like `zlib` that have ultra-stable APIs where the user spec didn't specify a version, it might even strip out the version number.  For sites that need to install 24 different versions of OpenMPI for different compiler/architecture combos, the function would have to include details on the dependencies.  We  call this the _spec mapping function_ (SMF).\n\nBy running the SMF on each user spec above, we get a bunch of _short specs_, each mapping to the fully concretized spec (and also a hash code for that spec).  For example:\n\n```\n[Short Spec] --> [User Spec] --> [Concretized Spec] --> [hash]\n-----------------------------------------------------------------\nnetcdf@4.1.1 --> netcdf@4.1.1~hdf5 --> netcdf@41.1......^...^..^... --> [hash1]\nzlib --> zlib --> zlib@1.2.8 --> [hash2]\nibmisc@0.1.2 --> ibmisc@0.1.2+python+netcdf ^netcdf-cxx4 ^netcdf+mpi ^eigen~suitesparse ^py-numpy+lapack ^openblas ^python@3: --> ibmisc@0.1.2...^...^..^.. --> [hash3]\n```\n\nNote that changes in Spack can cause _both_ the hash _and_ the concretized spec to change.  They can also require that the user spec for a desired install must also change, in some cases.  In that rare case, I can maintain my spec mapping function, possibly with the aid of a lookup dict, to ensure that short specs never change.\n\nThe proposal is then to make a directory of symlinks named after short specs, which would link into the main Spack installation directories for the hashes associated with each short spec.  When Spack changes, I would do the following to ensure consistency in my short specs:\n1. Review my user specs, make sure they don't require modification.\n2. If any user specs do require modification, make sure that the SMF() of those specs remains constant.  If needed, modify my SMF to make it so (for example, by adding ad-hoc lookup-based exceptions to some general SMF rule).\n3. Re-run `spack install` on all my short specs, creating a new directory of short spec symlinks.\n4. When (3) is complete, replace the old short spec symlinks with the new one.  Or keep them all side-by-side for exact repeatability for end users.\n\nThis approach does not address potential issues of \"unnecessary\" Spack rebuilds.  A new Spack could still come with a new version of `zlib` and trigger a rebuild of everything. The assumption here is that CPU time is (relatively) cheap, and that keeping things consistent for end users is the most important.\n\nThe benefits of allowing Spack to rebuild when it wants are _repeatability_ and _correctness_:\n1. The meaning of a user spec depends entirely on the spec itself and the version of Spack interpreting that spec; and NOTHING on whatever Spack happened to install in the past.\n2. It allows multiple projects with conflicting requirements to better co-exist within one Spack tree (since project B won't get confused by project A's already-installed dependencies).\n3. It ensure that software is always up-to-date, and that Spack doesn't \"guess wrong\" when it might decide that something doesn't need to be rebuilt after all --- avoiding a whole rats nest of virtual vs. actual version numbers we've proposed in the past.\n4. It efficiently removes versions of packages that have been removed from Spack due to security concerns.  (No more need for warnings on OpenSSL versions).\n\n@adamjstewart would this proposal help the issues you brought up in #1325?\n",
    "performed_via_github_app": null
}