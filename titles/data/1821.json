{
    "url": "https://api.github.com/repos/spack/spack/issues/1821",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/1821/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/1821/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/1821/events",
    "html_url": "https://github.com/spack/spack/issues/1821",
    "id": 178479836,
    "node_id": "MDU6SXNzdWUxNzg0Nzk4MzY=",
    "number": 1821,
    "title": "Spec interface for build information (like lib names, includes, etc.)",
    "user": {
        "login": "tgamblin",
        "id": 299842,
        "node_id": "MDQ6VXNlcjI5OTg0Mg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/299842?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tgamblin",
        "html_url": "https://github.com/tgamblin",
        "followers_url": "https://api.github.com/users/tgamblin/followers",
        "following_url": "https://api.github.com/users/tgamblin/following{/other_user}",
        "gists_url": "https://api.github.com/users/tgamblin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/tgamblin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/tgamblin/subscriptions",
        "organizations_url": "https://api.github.com/users/tgamblin/orgs",
        "repos_url": "https://api.github.com/users/tgamblin/repos",
        "events_url": "https://api.github.com/users/tgamblin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/tgamblin/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 446754070,
            "node_id": "MDU6TGFiZWw0NDY3NTQwNzA=",
            "url": "https://api.github.com/repos/spack/spack/labels/blas-lapack-scalapack",
            "name": "blas-lapack-scalapack",
            "color": "4477a8",
            "default": false,
            "description": null
        },
        {
            "id": 446630669,
            "node_id": "MDU6TGFiZWw0NDY2MzA2Njk=",
            "url": "https://api.github.com/repos/spack/spack/labels/dependencies",
            "name": "dependencies",
            "color": "c2e0c6",
            "default": false,
            "description": null
        },
        {
            "id": 446634397,
            "node_id": "MDU6TGFiZWw0NDY2MzQzOTc=",
            "url": "https://api.github.com/repos/spack/spack/labels/discussion",
            "name": "discussion",
            "color": "a87f5a",
            "default": false,
            "description": null
        }
    ],
    "state": "closed",
    "locked": false,
    "assignee": {
        "login": "alalazo",
        "id": 4199709,
        "node_id": "MDQ6VXNlcjQxOTk3MDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4199709?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alalazo",
        "html_url": "https://github.com/alalazo",
        "followers_url": "https://api.github.com/users/alalazo/followers",
        "following_url": "https://api.github.com/users/alalazo/following{/other_user}",
        "gists_url": "https://api.github.com/users/alalazo/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/alalazo/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/alalazo/subscriptions",
        "organizations_url": "https://api.github.com/users/alalazo/orgs",
        "repos_url": "https://api.github.com/users/alalazo/repos",
        "events_url": "https://api.github.com/users/alalazo/events{/privacy}",
        "received_events_url": "https://api.github.com/users/alalazo/received_events",
        "type": "User",
        "site_admin": false
    },
    "assignees": [
        {
            "login": "alalazo",
            "id": 4199709,
            "node_id": "MDQ6VXNlcjQxOTk3MDk=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4199709?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/alalazo",
            "html_url": "https://github.com/alalazo",
            "followers_url": "https://api.github.com/users/alalazo/followers",
            "following_url": "https://api.github.com/users/alalazo/following{/other_user}",
            "gists_url": "https://api.github.com/users/alalazo/gists{/gist_id}",
            "starred_url": "https://api.github.com/users/alalazo/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/alalazo/subscriptions",
            "organizations_url": "https://api.github.com/users/alalazo/orgs",
            "repos_url": "https://api.github.com/users/alalazo/repos",
            "events_url": "https://api.github.com/users/alalazo/events{/privacy}",
            "received_events_url": "https://api.github.com/users/alalazo/received_events",
            "type": "User",
            "site_admin": false
        }
    ],
    "milestone": null,
    "comments": 8,
    "created_at": "2016-09-21T22:39:24Z",
    "updated_at": "2017-03-16T14:35:49Z",
    "closed_at": "2017-03-16T14:35:49Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "Per discussion in #1682, reposting this for discussion.\n\nOne thing I thought about when looking at this PR: I don't _really_ like it that some dependents still search for their dependencies libraries, though I realize that it can be necessary.  Basically there are two guiding principles here:\n1. The dependencies know themselves best, and if they can expose their build information consistently, they should do that and let dependents access it.\n2. Dependents should prefer to ask dependencies for build information (lib locations, etc.) and only search if necessary.  Searching complicates build logic and Spack should already know where things are because it already installed the dependencies.\n\n(2) breaks down for external packages, which Spack didn't install and which may even be laid out differently than Spack would lay them out (e.g. a install of boost might have al the weird lib suffixes that boost supports, and I think Spack wouldn't currently know what to do with that).  Even better is that `find_libraries` is hidden behind a property interface so the client code doesn't know how the library names are being assigned.\n\nThis PR follows both of these principles for `LAPACK` and `BLAS`.  Using properties on specs for things like `blas_libs` and `lapack_libs` is great.  It doesn't follow these for `fftw`, `arpack`, `superlu`, etc.  See the `install` method for `armadillo`, which does its own `find` routines.\n\nI think this PR makes it clearer to me what a good convention for passing args among packages in a build should look like.  You want to ask the package for a property, and the package needs to know a) the property name and b) the `vdep` it's being asked as.  For non-virtual packages, (b) doesn't matter and is always just the plain package name, but when you're asked to provide the libs/headers for a particular _interface_, you need to know the interface name. \n\nI guess the question is whether this should be a convention or a more formal interface.  The convention currently looks like:\n\n``` python\n    spec['blas'].blas_libs\n    spec['lapack'].lapack_libs\n```\n\nSlightly annoying things about it:\n1. You have to write the interface twice even though you know what you asked for.\n1. The interface name is written once as a string and once as a property name prefix.\n\nSo, think we could have a convention like this:\n\n``` python\n\ndef provider_property(function):\n    \"\"\"Function object for grabbing build properties from dependency Packages.\"\"\"\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self, provider):\n        \"\"\"Get provider-specific property if available, or default to generic property.\"\"\"\n        specific = provider.replace('-', '_') + '_' + self.name\n        dep = spec[provider]\n        if hasattr(dep, specific):\n            return getattr(dep, specific)\n        else:\n            return getattr(dep, self.name)  # default to generic attribute\n\n\nclass Spec(object):\n    ...\n    libs = provider_property('libs')\n    includes = provider_property('includes')\n```\n\nNow the interface looks like this:\n\n``` python\n    spec.libs('blas')\n    spec.libs('lapack')\n```\n\nAnd you've got a convention for properties to add to packages (`libs`, `<provider>_libs`, etc.).  `Package` could provide a default implementation:\n\n``` python\nclass Package(object):\n    ...\n    def libs(self):\n        # requiring installation allows us to be more generic b/c we can search,\n        # but it does restrict when you can call the method.\n        assert(self.installed)    \n\n        return find_libraries(... something that returns all the libs in `lib` or `lib64`...)\n```\n\nAnd packages that need to can add things like `blas_libs`, `lapack_libs`, `superlu_dist_libs`, etc. as they do in this PR.  Packages like `arpack` and `superlu` can do nothing b/c we find their libs automatically and they're available through, e.g. `spec.libs('arpack')`.\n\nI guess the question is whether the interface above is so much better than the simple convention we've got that it's worthwhile.  The current convention is not so bad.  I think it boils down which is simpler to document and teach to package authors.  \n\nThe other question is whether this convention is worthwhile for non-virtuals.  Sometimes the client needs to be specific about which lib names it needs, in which case find_libraries seems like the right thing to do.\n\nWhat do you all think?\n",
    "performed_via_github_app": null
}