{
    "url": "https://api.github.com/repos/spack/spack/issues/640",
    "repository_url": "https://api.github.com/repos/spack/spack",
    "labels_url": "https://api.github.com/repos/spack/spack/issues/640/labels{/name}",
    "comments_url": "https://api.github.com/repos/spack/spack/issues/640/comments",
    "events_url": "https://api.github.com/repos/spack/spack/issues/640/events",
    "html_url": "https://github.com/spack/spack/issues/640",
    "id": 143541023,
    "node_id": "MDU6SXNzdWUxNDM1NDEwMjM=",
    "number": 640,
    "title": "Relative RPATHs (or RUNPATHs) for Relocatability",
    "user": {
        "login": "citibeth",
        "id": 1924215,
        "node_id": "MDQ6VXNlcjE5MjQyMTU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1924215?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/citibeth",
        "html_url": "https://github.com/citibeth",
        "followers_url": "https://api.github.com/users/citibeth/followers",
        "following_url": "https://api.github.com/users/citibeth/following{/other_user}",
        "gists_url": "https://api.github.com/users/citibeth/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/citibeth/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/citibeth/subscriptions",
        "organizations_url": "https://api.github.com/users/citibeth/orgs",
        "repos_url": "https://api.github.com/users/citibeth/repos",
        "events_url": "https://api.github.com/users/citibeth/events{/privacy}",
        "received_events_url": "https://api.github.com/users/citibeth/received_events",
        "type": "User",
        "site_admin": false
    },
    "labels": [
        {
            "id": 73908756,
            "node_id": "MDU6TGFiZWw3MzkwODc1Ng==",
            "url": "https://api.github.com/repos/spack/spack/labels/feature",
            "name": "feature",
            "color": "84b6eb",
            "default": false,
            "description": null
        }
    ],
    "state": "closed",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": null,
    "comments": 1,
    "created_at": "2016-03-25T16:55:11Z",
    "updated_at": "2017-11-22T06:57:22Z",
    "closed_at": "2017-11-22T06:57:22Z",
    "author_association": "MEMBER",
    "active_lock_reason": null,
    "body": "Generate RPATHs using the $ORIGIN feature, which would make Spack installations trivially relocatable (via mv).  I see no downside to this feature.   See discussion below...\n\nRelocatability\nThe setup/machines for building an the setup for deploying the build artifacts on network filesystems are not always the same. Thus build artifacts may either need to be fully relocatable, or support some relocate/post-install hooks. We experimented already a bit with it, but wonder whether others have similar problems to solve and already did some work in that direction.\n\nWhat is the fundamental technology you plan on using to provide relocatability?  Rpath?  Runpath?  LD_LIBRARY_PATH?  With a specific approach in mind, I think we can design Spack to accommodate it.\n\nUp to now we purely relied on LD_LIBRARY_PATH in our community. But we could like to re-start experimenting w. relative RUNPATHS again. We only ended up w/ half-baked solutions there, as we never invested the required amount of time.\n1. I think that Spack could certainly generate RPATHs with $ORIGIN in them.\n      http://man7.org/linux/man-pages/man8/ld.so.8.html\n   I see no downside to this, and it would allow an entire repository of Spack builds to be relocated.  Would that be enough relocatibility?  Or do you want to relocate individual packages relative to each other?\n\nRelocatable RPATHs with $ORIGIN would complicate the multiple-repo idea below...\n1. We've had some discussion on RPATH vs. RUNPATH (I believe over at EasyBuild).  The consensus seemed to be that whatever your opinion about the merits of one vs. the other, tools like Spack should be able to set either one, if the user so desires.  It's just so easy.  This applies to Spack, which needs an option to build with RUNPATH (instead of the current RPATH).  Is anyone opposed to this feature?\n\nhttp://blog.tremily.us/posts/rpath/\n1. Tools like chrpath can be used to build a relocation strategy based on changing an RPATH when a package is being relocated.  To support this usage, Spack would need to pad its RPATHs to be at least as long as the final RPATH you are intending to install in.  Anyone object to this feature?\n2. LD_LIBRARY_PATH is evil.\n   https://www.google.com/search?q=ld_library_path+evil&ie=utf-8&oe=utf-8\n   My experience with EasyBuild (which relies on LD_LIBRARY_PATH) confirms this.  In theory, things should work.  In practice, I somehow end up with the wrong modules loaded, and the wrong LD_LIBRARY_PATH, and then things stop working.\n3. One fundamental issue that needs to be solved with Spack (or Spack-like) systems is transitive dependencies.  If A depends on B and B depends on C (A -> B -> C), then A needs to find libC.so when loading.  Here are some common solutions I've seen:\n   a) Traditionally, this was not such a problem because A, B and C all existed in the same directory tree.  This solution is fundamentally incompatible with Spack.\n   b) EasyBuild installs each package in a separate tree, like Spack.  It then uses transitive modules (via Lmod) to piece together the right LD_LIBRARY_PATH.  So... when I say \"module load A\", Lmod also loads EasyBuild-generated modules B and C.  I then have the correct LD_LIBRARY_PATH to run things from package A (but the wrong LD_LIBRARY_PATH to run things from any other package...)\n   c) Spack uses RPATH to ensure the proper libraries get loaded.  In the end... if you can FIND A, then you can load it successfully.\n\nIn my experience, approach (c) has worked far better than (b).  Spack does not generate transitive modules, which you might want for PATH-like things other than the Linux loader (eg, PYTHON_PATH).  Spack might get transitive modules someday.  I came to Spack thinking transitive modules was a must-have feature.  But now having used it, I feel it's a low-priority feature, I really haven't missed it.\n1. All of this is OS-dependent.  Anything we figure out on Linux might be different on MacOS, because the MacOS loader is different.\n",
    "performed_via_github_app": null
}